/*
 * rsa.c
 * Author: Morella, Mae
 *
 * MIT license
 *
 * Copyright (c) 2021 Morella, Mae
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#include <assert.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>

struct KeyPair {
  unsigned long e;
  unsigned long n;
};

// The value returned by extended_gcd
struct EuclidTriple {
  unsigned long d;  // the greatest common denominator of the inputs
  long x;           // an integer such that d = ax + by
  long y;           // an integer such that d = ax + by
};

// Returns (d, x, y) where d is the GCD of a, b
// x and y are assigned such that d = ax + by
struct EuclidTriple extended_gcd(long a, long b) {
  struct EuclidTriple t = {b, 0, 1};
  if (a != 0) {
    struct EuclidTriple p = extended_gcd(b % a, a);
    t.d = p.d;
    t.x = p.y - (b / a) * p.x;
    t.y = p.x;
  }
  assert(t.d == (a * t.x) + (b * t.y));
  return t;
}

// Returns the multiplicative inverse of a, modulo n
// Precondition: n > 1, a and n are relatively prime.
unsigned long mult_inverse_mod(long a, long n) {
  struct EuclidTriple t = extended_gcd(a, n);
  assert(t.d == 1);  // verify precond: a, n are coprime iff gcd (a,n) = 1.
  // use modulo twice, to ensure that x is the positive remainder
  int x = (t.x % n + n) % n;
  printf("%d\n", x);
  assert((a * x) % n == 1);  // check that d is the mult inverse
  return x;
}

// Returns a^b (mod n)
// Precond: a, b >= 0, n > 0
unsigned long modular_exponentiation(unsigned long a, unsigned long b,
                                     unsigned long n) {
  int c = 0;
  int d = 1;
  int width = (int)log2(b) + 1;
  for (int i = width; i >= 0; i--) {
    c = 2 * c;
    d = (d * d) % n;
    if ((b >> i) & 1 == 1) {
      c += 1;
      d = (d * a) % n;
    }
  }
  return d;
}

// Generates an RSA encryption key.
// Precondition: p, q are prime numbers. e is an odd number which is relatively
// prime to (p - 1)(q - 1).
struct KeyPair generate_public_key(unsigned int p, unsigned int q,
                                   unsigned int e) {
  // Assert the precondition that e and phi are relatively prime
  assert(extended_gcd(e, (p - 1) * (q - 1)).d == 1);
  int n = p * q;
  struct KeyPair public = {e, n};
  return public;
}
//  Generates an RSA encryption key.
// Precondition: p, q are prime numbers. e is an odd number which is relatively
// prime to (p - 1)(q - 1).
// Postcond: The key generated by generate_private_key(p, q, e) corresponds to
// the one generated by calling generate_public_key with the same inputs.
struct KeyPair generate_private_key(unsigned int p, unsigned int q,
                                    unsigned int e) {
  unsigned long n = p * q;
  unsigned long phi = (p - 1) * (q - 1);
  int d = mult_inverse_mod(e, phi);
  struct KeyPair private = {d, n};
  return private;
}

unsigned int crypt(unsigned long msg, struct KeyPair *key) {
  return modular_exponentiation(msg, key->e, key->n);
}

int main(int argc, char *argv[]) {
  FILE *f = fopen("keygen.env", "r");
  if (!f) {
    fprintf(stderr, "Error opening keygen.env!\n");
    return EXIT_FAILURE;
  }
  unsigned long p, q, e;
  fscanf(f, "%lu,%lu,%lu", &p, &q, &e);
  struct KeyPair pub = generate_public_key(p, q, e);
  printf("Public key: {%lu,%lu}\n", pub.e, pub.n);
  struct KeyPair priv = generate_private_key(p, q, e);
  printf("Private key: {%lu,%lu}\n", priv.e, priv.n);
  printf("Enter a number to encrypt: ", pub.n);
  unsigned long message;
  scanf("%zzu", &message);
  unsigned int msg = crypt(message, &pub);
  printf("encrypted: %d\n", msg);
  printf("decrypted: %d\n", crypt(msg, &priv));
  fclose(f);
  return EXIT_SUCCESS;
}